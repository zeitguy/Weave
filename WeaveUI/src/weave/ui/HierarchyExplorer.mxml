<?xml version="1.0" encoding="utf-8"?>
<!--
/*
    Weave (Web-based Analysis and Visualization Environment)
    Copyright (C) 2008-2011 University of Massachusetts Lowell

    This file is a part of Weave.

    Weave is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License, Version 3,
    as published by the Free Software Foundation.

    Weave is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Weave.  If not, see <http://www.gnu.org/licenses/>.
*/
-->
<mx:HDividedBox
	xmlns:ui ="weave.ui.*"
	xmlns:mx="http://www.adobe.com/2006/mxml"
	implements="weave.api.core.ILinkableObject"
	width="100%" height="100%"
	>

	<mx:VBox id="folderVBox" width="100%" height="100%"
			 verticalScrollPolicy="off" horizontalScrollPolicy="off">
		<ui:WeaveTree id="folderView" width="100%" height="100%"
					   showDataTips="true"
					   allowMultipleSelection="false"
					   itemClose="handleFolderCollapse(event)"
					   doubleClickEnabled="true" doubleClick="handleFolderDoubleClick()"/>
	</mx:VBox>
	<mx:VBox id="fileVBox" width="100%" height="100%"
			 verticalScrollPolicy="off" horizontalScrollPolicy="off">
		<ui:WeaveTree id="fileView" width="100%" height="100%"
					   showDataTips="true"
					   disclosureClosedIcon="{null}" disclosureOpenIcon="{null}"
					   itemOpen="handleFileDoubleClick()"
					   doubleClickEnabled="true" doubleClick="handleFileDoubleClick()"/>
	</mx:VBox>

	<mx:Script>
		<![CDATA[
			import mx.binding.utils.BindingUtils;
			import mx.controls.Tree;
			import mx.events.TreeEvent;
			
			import weave.api.core.ILinkableObject;
			import weave.api.data.IWeaveTreeNode;
			import weave.api.newLinkableChild;
			import weave.api.registerLinkableChild;
			import weave.core.LinkableString;
			import weave.core.LinkableWatcher;
			import weave.utils.EventUtils;
			
//			public const folderFilter:LinkableString = registerLinkableChild(this, new LinkableString('', isNonNull));
			public const fileFilter:LinkableString = registerLinkableChild(this, new LinkableString('', isNonNull));
			private const rootWatcher:LinkableWatcher = newLinkableChild(this, LinkableWatcher);
			
			private function isNonNull(value:String):Boolean { return value != null; }
			
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				
				registerLinkableChild(folderView, rootWatcher);
				registerLinkableChild(fileView, rootWatcher);
				
				folderView.dataDescriptor = new WeaveTreeDataDescriptor(1);
//				folderFilter.addGroupedCallback(this, refreshFolders);
				// using a delayed callback to avoid clearing the file list during an update
				BindingUtils.bindSetter(EventUtils.generateDelayedCallback(this, refreshFiles, 0, true), folderView, 'selectedItem');
				
				fileView.dataDescriptor = new WeaveTreeDataDescriptor(2);
				fileFilter.addGroupedCallback(this, refreshFiles);
				
				folderView.addEventListener(KeyboardEvent.KEY_DOWN, handleFolderKeyDown, false, int.MAX_VALUE);
				fileView.addEventListener(KeyboardEvent.KEY_DOWN, handleFileKeyDown, false, int.MAX_VALUE);
			}
			
			public function set rootNode(node:IWeaveTreeNode):void
			{
				rootWatcher.target = node as ILinkableObject;
				folderView.rootNode = node;
			}
			
			public function get selectedFolder():IWeaveTreeNode
			{
				return folderView.selectedItem as IWeaveTreeNode;
			}
			
			private var _prevFolder:IWeaveTreeNode;
			
			private function refreshFiles(folder:IWeaveTreeNode = null):void
			{
				if (!folder)
					folder = selectedFolder;
				
				fileVBox.visible = fileVBox.includeInLayout = !!folder;
				
				if (_prevFolder != folder)
				{
					_prevFolder = folder;
					if (folder && folder.hasChildBranches())
						folderView.expandItem(folder, true);
					fileFilter.value = '';
				}
				
				var files:Array;
				if (folder)
				{
					files = folder.getChildren();
					if (files)
						files = files.filter(fileFilterFunction);
				}
				fileView.refreshDataProvider(files || []);
			}

//			private function folderFilterFunction(node:IWeaveTreeNode):Boolean
//			{
//				return node.getLabel().toLowerCase().search(folderFilter.value.toLowerCase()) >= 0;
//			}

			private function fileFilterFunction(node:IWeaveTreeNode, i:int, a:Array):Boolean
			{
				return node.getLabel().toLowerCase().search(fileFilter.value.toLowerCase()) >= 0;
			}

			private function handleFolderCollapse(event:TreeEvent):void
			{
				// if collapsing a node would make the current selection disappear, select the collapsing node
				var collapsing:IWeaveTreeNode = event.item as IWeaveTreeNode;
				if (selectionWouldDisappear(folderView, collapsing, selectedFolder))
					folderView.selectedItem = _prevFolder = collapsing;
			}
			
			private function selectionWouldDisappear(tree:Tree, collapsing:IWeaveTreeNode, selected:IWeaveTreeNode):Boolean
			{
				if (!collapsing || !selected)
					return false;
				
				var children:Array = collapsing.getChildren();
				if (children.indexOf(selected) >= 0)
					return true;
				
				// first test if child item is open before requesting children with the recursive call
				for each (var child:IWeaveTreeNode in children)
					if (tree.isItemOpen(child) && selectionWouldDisappear(tree, child, selected))
						return true;
				
				return false;
			}
			
			private function handleFolderDoubleClick():void
			{
				// Toggle expanded state.
				// Note that this will toggle the folder icon whether or not the node has child branches.
				// Also note that the same behavior occurs when using the left and right arrow keys.
				// We could check node.hasChildBranches() before toggling expanded state, but the user may find marking the folder icons useful.
				var folder:IWeaveTreeNode = selectedFolder;
				if (folder)
					folderView.expandItem(folder, !folderView.isItemOpen(folder));
			}
			private function handleFileDoubleClick():void
			{
				var node:IWeaveTreeNode = fileView.selectedItem as IWeaveTreeNode;
				if (node && node.isBranch())
				{
					// expand parent, scroll to, and select
					folderView.expandItem(folderView.selectedItem, true);
					folderView.scrollToAndSelectMatchingItem(
						function(folder:IWeaveTreeNode):Boolean {
							return folder == node;
						}
					);
				}
			}
			
			private function handleFolderKeyDown(event:KeyboardEvent):void
			{
				// press ENTER key on folder -> focus fileView
				if (event.keyCode == Keyboard.ENTER && selectedFolder)
				{
					fileView.setFocus();
					event.preventDefault();
				}
				
				// press RIGHT key on folder with no subfolders -> focus fileView
				if (event.keyCode == Keyboard.RIGHT && selectedFolder && !selectedFolder.hasChildBranches())
				{
					fileView.setFocus();
					event.preventDefault();
				}
			}
			
			private function handleFileKeyDown(event:KeyboardEvent):void
			{
				var selectedFile:IWeaveTreeNode = fileView.selectedItem as IWeaveTreeNode;
				
				// press ENTER or RIGHT on folder in file view -> same as doubleClick
				if ((event.keyCode == Keyboard.ENTER || event.keyCode == Keyboard.RIGHT) && selectedFile && selectedFile.isBranch())
				{
					handleFileDoubleClick();
					event.preventDefault();
				}
				
				// press LEFT on folder in file view -> go to parent folder or close file view if there is no parent folder
				if (event.keyCode == Keyboard.LEFT)
				{
					var parent:IWeaveTreeNode = folderView.getParentItem(selectedFolder) as IWeaveTreeNode;
					if (parent)
						folderView.selectedItem = parent;
					else
					{
						folderView.selectedItem = null;
						folderView.setFocus();
						refreshFiles();
					}
					event.preventDefault();
				}
			}
		]]>
	</mx:Script>
</mx:HDividedBox>
