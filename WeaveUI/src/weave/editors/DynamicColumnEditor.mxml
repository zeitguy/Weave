<?xml version="1.0" encoding="utf-8"?>
<!--
/*
    Weave (Web-based Analysis and Visualization Environment)
    Copyright (C) 2008-2011 University of Massachusetts Lowell

    This file is a part of Weave.

    Weave is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License, Version 3,
    as published by the Free Software Foundation.

    Weave is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Weave.  If not, see <http://www.gnu.org/licenses/>.
*/
-->

<mx:VBox width="100%" height="100%"
	xmlns="weave.editors.*"
	xmlns:ui="weave.ui.*"
	xmlns:mx="http://www.adobe.com/2006/mxml"
	verticalScrollPolicy="off" horizontalScrollPolicy="off"
	implements="weave.api.core.ILinkableObject,weave.api.ui.ILinkableObjectEditor"
	>
	<ui:HierarchyExplorer id="explorer"/>
	<ui:BusyIndicator id="busyIndicator" targets="{[explorer]}"/>
	<mx:HBox id="dummyHBox" minWidth="0" width="100%"
			 borderColor="#000000" 
			 horizontalScrollPolicy="off" verticalScrollPolicy="off">
		<ui:TextInputWithPrompt id="folderSearchInput"
					  prompt="{lang('Search')}"
					  width="100%"/>
		<ui:TextInputWithPrompt id="fileSearchInput"
					  prompt="{lang('Search')}"
					  width="100%"/>
	</mx:HBox>
	
	<mx:Script>
		<![CDATA[
			import mx.binding.utils.BindingUtils;
			
			import weave.api.copySessionState;
			import weave.api.core.ILinkableHashMap;
			import weave.api.core.ILinkableObject;
			import weave.api.data.IColumnReference;
			import weave.api.data.IDataSource;
			import weave.api.data.IWeaveTreeNode;
			import weave.api.getCallbackCollection;
			import weave.api.linkBindableProperty;
			import weave.api.newLinkableChild;
			import weave.api.registerLinkableChild;
			import weave.core.LinkableWatcher;
			import weave.data.AttributeColumns.DynamicColumn;
			import weave.data.AttributeColumns.ReferencedColumn;
			import weave.data.hierarchy.DataSourceTreeNode;
			
			public const referencedColumn:ReferencedColumn = newLinkableChild(this, ReferencedColumn, copyToTarget);
			private const targetWatcher:LinkableWatcher = newLinkableChild(this, LinkableWatcher, copyFromTarget);
			
			public function get target():DynamicColumn
			{
				return targetWatcher.target as DynamicColumn;
			}
			
			public function setTarget(newTarget:ILinkableObject):void
			{
				targetWatcher.target = newTarget as DynamicColumn;
			}
			public function hasPendingChanges():Boolean { return false; }
			public function applyChanges():void { }
			
			public function set dataSource(ds:IDataSource):void
			{
				dataSourceWatcher.target = ds;
			}
			private const dataSourceWatcher:LinkableWatcher = newLinkableChild(this, LinkableWatcher, handleDataSource);
			private function handleDataSource():void
			{
				var ds:IDataSource = dataSourceWatcher.target as IDataSource;
				explorer.rootNode = ds ? ds.getHierarchyRoot() : null;
				explorer.folderView.showRoot = !!ds;
			}
			
			override protected function createChildren():void
			{
				super.createChildren();
				
				// remove the dummy because we don't want it on the screen
				removeChild(dummyHBox);
				
//				explorer.folderVBox.addChildAt(folderSearchInput, 0);
				explorer.fileVBox.addChildAt(fileSearchInput, 0);
				
				registerLinkableChild(this, explorer);

				explorer.rootNode = new DataSourceTreeNode();
				
				explorer.folderView.dragEnabled = false;
				explorer.fileView.dragEnabled = true;
				//explorer.attributeView.addEventListener(DragEvent.DRAG_START, handleAttributeDrag);
				
				BindingUtils.bindSetter(handleSelection, explorer.fileView, 'selectedItem');
//				linkBindableProperty(explorer.folderFilter, folderSearchInput, 'text', 200);
				linkBindableProperty(explorer.fileFilter, fileSearchInput, 'text', 200);
			}
			
			private function handleSelection(node:IWeaveTreeNode):void
			{
				var ref:IColumnReference = node as IColumnReference;
				if (ref)
				{
					var meta:Object = ref.getColumnMetadata();
					if (meta)
						referencedColumn.setColumnReference(ref.getDataSource(), meta);
				}
			}
			
			/**
			 * Adds multiple columns to an ILinkableHashMap.
			 * @param destination The hash map where columns should be added.
			 * @param selectedOnly If true, adds selected columns.  If false, adds all visible columns
			 * @return An Array of columns that were added to the hash map.
			 */
			public function addMultipleColumns(destination:ILinkableHashMap, selectedOnly:Boolean):Array
			{
				var result:Array = [];
				var folder:IWeaveTreeNode = explorer.folderView.selectedItem as IWeaveTreeNode;
				if (!folder)
					return result;
				
				var nodes:Array;
				if (selectedOnly)
				{
					nodes = explorer.fileView.selectedItems;
					// selectedItems order is reversed
					if (nodes)
						nodes = nodes.concat().reverse();
				}
				else
				{
					nodes = folder.getChildren();
				}
				
				referencedColumn.delayCallbacks();
				getCallbackCollection(destination).delayCallbacks();
				for each (var node:IWeaveTreeNode in nodes)
				{
					var ref:IColumnReference = node as IColumnReference;
					if (ref)
					{
						var meta:Object = ref.getColumnMetadata();
						if (meta !== null)
						{
							referencedColumn.setColumnReference(ref.getDataSource(), meta);
							result.push(destination.requestObjectCopy(null, referencedColumn));
						}
					}
				}
				getCallbackCollection(destination).resumeCallbacks();
				referencedColumn.resumeCallbacks();
				
				return result;
			}
			
			private function copyToTarget():void
			{
				if (target)
					target.requestLocalObjectCopy(referencedColumn);
			}
			
			private function copyFromTarget():void
			{
				if (target && target.internalObject is ReferencedColumn)
					copySessionState(target.internalObject, referencedColumn);
			}
			
			public function clearSearch():void
			{
				fileSearchInput.text = '';
				folderSearchInput.text = '';
				
				explorer.fileFilter.value = '';
//				explorer.folderFilter.value = '';
			}
			
			/*
			private function handleAttributeDrag(event:MouseEvent):void
			{
				var ds:DragSource = new DragSource();
				ds.addData(explorer.attributeView.selectedItems,"items");
				
				var targetList:List = (event.currentTarget as List);
				if (targetList.dataProvider != null)// && targetList.dropEnabled)
				{
					var selectedIndex:int = (event.currentTarget as List).selectedIndex;
					var dragInitiator:IUIComponent = (event.currentTarget as List).indexToItemRenderer(selectedIndex);
					if (dragInitiator)
						DragManager.doDrag(dragInitiator,ds,event);
				}
			}
			*/
		]]>
	</mx:Script>
</mx:VBox>
